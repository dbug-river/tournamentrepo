package com.rivertech.services;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.UUID;

import com.rivertech.model.Round;
import com.rivertech.model.Slot;


public class Planner {
		
	public boolean hasCollision(Round a, Round b) {
		
		/* If the round is the same round, return collision */
		if(a.getId() == b.getId()) {
			return true;
		}
		
		/* Two games cannot happen at the same time */
		if(a.getGame().getGameId() == b.getGame().getGameId()) {
			return true;
		}
		
		/* Users cannot collide with each other */
		int collidingUsers = 0;
		HashSet<String> aSet = new HashSet<String>(Arrays.asList(a.getUsers()));
		for (String userId : b.getUsers()) {
            if (aSet.contains(userId)) {
            	collidingUsers ++;
            }
            if(collidingUsers > 0) {
            	return true;
            }
        }
				
		return false;
	}

	public List<Slot> fit(List<Round> rounds) {
		
		/* List of completed slots */
		List<Slot> fittedSlots = new ArrayList<>();
		
		/* List of fitted rounds */
		List<Round> fittedRounds = new ArrayList<>();
		
		/* Loop through each round and try to match non colliding rounds */
		for(Round roundA : rounds) {
			
			/* Check if the current round is already fitted */
			if(fittedRounds.contains(roundA)) {
				/* The round is already fitted */
				continue;
			}
			
			/* Create a slot */
			Slot slot = new Slot();
			/* Set the first round of the slot as round A */
			slot.setOne(roundA);
			/* Add roundA to the fitted list */
			fittedRounds.add(roundA);
			
			/* Find a non-colliding entry */
			for(Round roundB : rounds) {

				/* Check if the current round is already fitted */
				if(fittedRounds.contains(roundB)) {
					/* The round is already fitted */
					continue;
				}
				
				if(!hasCollision(roundA, roundB)) {
					/* Set the second round of the slot as round B */
					slot.setTwo(roundB);
					/* Add roundB to the fitted list */
					fittedRounds.add(roundB);
					break;
				}
			}
			
			/* Once done add the slot to the final collection */
			fittedSlots.add(slot);			
		}
		/* Return fitted slots */
		return fittedSlots;
	}
	
	public List<Slot> solve(List<Round> rounds, int maxSlots){
		
		/* Loop through each combination and create a fit */
		for(int i = 0; i < rounds.size(); i++) {
			 Collections.swap(rounds, 0, i);
			 /* Compute a fit */ 
			 List<Slot> slots = fit(rounds);
			 if(slots.size() <= maxSlots)
				 return slots;
		}
		
		return new ArrayList<>();
	}
}
